from dataclasses import dataclass
import numpy as np


@dataclass
class basic_parameters:
    years: int
    channels_impressions: list[str]
    channels_clicks: list[str]
    frequency_of_campaigns: int
    start_date: str
    true_cvr: list = None
    revenue_per_conv: str = None

    def __post_init__(self):
        self.evaluate_params()

    def evaluate_params(self):
        assert self.years > 0, "You entered less than 1 year. Must generate more than a years worth of data"
        if self.true_cvr != None:
            assert len(self.true_cvr) == len(self.channel_clicks) + len(self.channel_clicks), "True CVR must have equal number of entries as channel impressions and channel clicks"
            for cvr in self.true_cvr:
                assert 0 < cvr <= 1, "You've entered an invalid True CVR value. CVR values must be greater than 0 and less than or equal to 1"
        assert self.frequency_of_campaigns >= 1, "You entered a frequency of campaigns less than 1. You must enter a number greater than 1"

    def __repr__(self):
        channel_use_impressions = ", ".join(self.channels_impressions)
        channel_use_clicks = ", ".join(self.channels_clicks)
        cvr_values = ", ".join([str(cvr) for cvr in self.true_cvr]) if self.true_cvr != None else ""

        slug = f"""Years of Data to generate : {self.years}
Channel that use impressions : {channel_use_impressions}
Channel that use clicks : {channel_use_clicks}
How frequently campaigns occur : {self.frequency_of_campaigns}
True CVRs of a channel (in order of channels you specified) : {cvr_values}
Revenue per conversion : {self.revenue_per_conv}
Date the data set will start with : {self.start_date}"""

        return slug


@dataclass
class baseline:
    basic_params: basic_parameters
    base_p: int
    trend_p: int
    temp_var: int
    temp_coef_mean: int
    temp_coef_sd: int
    error_std: int

    def __post_init__(self):
        assert self.error_std < self.base_p, "Error std can not exceed base sales value"
        self.calculate_params()

    def calculate_params(self):
        # Number of days to generate data for
        days = np.arange(0,self.basic_params.years*365)

        # Base sales of base_p units
        base = np.zeros(shape=self.basic_params.years*365) + self.base_p

        #Trend of trend_p extra units per day
        trend_cal = (self.trend_p/(self.basic_params.years*365))*self.base_p
        trend = trend_cal * days

        #Temperature generated by a sin function and we can manipulate how much the sin function goes up or down with temp_var
        temp = self.temp_var * np.sin(days*3.14/182.5)

        # coefficient of temperature's effect on sales will be a random variable with normal distribution
        seasonality = np.random.normal(loc = self.temp_coef_mean, scale = self.temp_coef_sd, size = 1) * temp

        # add some noise to the trend
        error = np.random.normal(loc=0, scale=self.error_std, size=self.basic_params.years*365)

        # Generate series for baseline sales
        baseline_sales = base + trend + seasonality + error

        # if error term makes baseline_sales negative, make it 0
        baseline_sales = np.where(baseline_sales < 0, 0, baseline_sales)

        self.output = np.array([days, baseline_sales, base, trend, temp, seasonality, error])
